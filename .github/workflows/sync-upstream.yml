name: Sync with Upstream

on:
  schedule:
    - cron: '0 * * * *'  # Every hour
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/BeehiveInnovations/gemini-mcp-server.git || true
          git fetch upstream

      - name: Check for updates
        id: check_updates
        run: |
          # Get latest commit from upstream
          UPSTREAM_SHA=$(git rev-parse upstream/main)
          UPSTREAM_SHORT=$(git rev-parse --short upstream/main)
          
          # Get latest commit from our main
          OUR_SHA=$(git rev-parse origin/main)
          OUR_SHORT=$(git rev-parse --short origin/main)
          
          echo "upstream_sha=$UPSTREAM_SHA" >> $GITHUB_OUTPUT
          echo "upstream_short=$UPSTREAM_SHORT" >> $GITHUB_OUTPUT
          echo "our_sha=$OUR_SHA" >> $GITHUB_OUTPUT
          echo "our_short=$OUR_SHORT" >> $GITHUB_OUTPUT
          
          if [ "$UPSTREAM_SHA" = "$OUR_SHA" ]; then
            echo "needs_update=false" >> $GITHUB_OUTPUT
            
            # Create nice summary for up-to-date status
            echo "## âœ… Repository is up-to-date with upstream" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current commit:** \`$OUR_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "**Upstream commit:** \`$UPSTREAM_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No synchronization needed. The fork is already synchronized with the upstream repository." >> $GITHUB_STEP_SUMMARY
            
            echo "::notice title=Up-to-date::Repository is already synchronized with upstream (commit: $OUR_SHORT)"
          else
            echo "needs_update=true" >> $GITHUB_OUTPUT
            
            # Count commits behind
            COMMITS_BEHIND=$(git rev-list --count origin/main..upstream/main)
            echo "commits_behind=$COMMITS_BEHIND" >> $GITHUB_OUTPUT
            
            echo "::notice title=Updates Available::Found $COMMITS_BEHIND new commits from upstream"
          fi

      - name: Create sync branch and merge
        if: steps.check_updates.outputs.needs_update == 'true'
        id: create_branch
        run: |
          echo "::group::Creating sync branch"
          # Generate unique branch name
          BRANCH_NAME="sync/upstream-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Create and checkout new branch from main
          git checkout -b $BRANCH_NAME origin/main
          echo "Created branch: $BRANCH_NAME"
          echo "::endgroup::"
          
          echo "::group::Merging upstream changes"
          # Get list of changed files before merge
          CHANGED_FILES=$(git diff --name-only origin/main upstream/main | head -20)
          
          # Merge upstream changes with strategy to always accept theirs
          git merge upstream/main --no-edit --strategy-option=theirs || {
            # If merge still fails, use more aggressive approach
            echo "Standard merge failed, using reset approach..."
            
            # Save our protected files
            cp .github/workflows/auto-version.yml /tmp/auto-version.yml.bak 2>/dev/null || true
            cp .github/workflows/build_and_publish_docker.yml /tmp/build_and_publish_docker.yml.bak 2>/dev/null || true
            cp .github/workflows/sync-upstream.yml /tmp/sync-upstream.yml.bak 2>/dev/null || true
            cp docker-compose.yml /tmp/docker-compose.yml.bak 2>/dev/null || true
            cp Dockerfile /tmp/Dockerfile.bak 2>/dev/null || true
            
            # Force merge with theirs strategy
            git merge upstream/main --no-edit --strategy=ours --allow-unrelated-histories
            
            # Checkout all files from upstream (including their workflows)
            git checkout upstream/main -- .
            
            # Restore our protected files
            cp /tmp/auto-version.yml.bak .github/workflows/auto-version.yml 2>/dev/null || true
            cp /tmp/build_and_publish_docker.yml.bak .github/workflows/build_and_publish_docker.yml 2>/dev/null || true
            cp /tmp/sync-upstream.yml.bak .github/workflows/sync-upstream.yml 2>/dev/null || true
            cp /tmp/docker-compose.yml.bak docker-compose.yml 2>/dev/null || true
            cp /tmp/Dockerfile.bak Dockerfile 2>/dev/null || true
            
            # Add our protected files back
            git add .github/workflows/auto-version.yml .github/workflows/build_and_publish_docker.yml .github/workflows/sync-upstream.yml docker-compose.yml Dockerfile
            git commit --amend --no-edit
          }
          echo "::endgroup::"
          
          # Append Docker usage section to README if it doesn't exist
          if ! grep -q "## Docker Image Usage (Fork Enhancement)" README.md; then
            echo "::group::Appending Docker section to README"
            cat >> README.md << 'DOCKER_SECTION'

            ## Docker Image Usage (Fork Enhancement)

            This fork maintains Docker support with pre-built images available at GitHub Container Registry.

            ### Quick Start with Docker

            **Basic Configuration (Gemini only):**
            ```json
            {
              "mcpServers": {
                "zen": {
                  "command": "docker",
                  "args": [
                    "run", "--rm", "-i",
                    "-e", "GEMINI_API_KEY=<your_api_key_from_google_ai_studio>",
                    "-v", "<path_to_your_workspace>:<path_to_your_workspace>",
                    "ghcr.io/patrykiti/zen-mcp-server:latest"
                  ]
                }
              }
            }
            ```

            **Full Configuration (All Providers):**
            ```json
            {
              "mcpServers": {
                "zen": {
                  "command": "docker",
                  "args": [
                    "run", "--rm", "-i",
                    "-e", "GEMINI_API_KEY=<your-gemini-key>",
                    "-e", "OPENAI_API_KEY=<your-openai-key>",
                    "-e", "XAI_API_KEY=<your-xai-key>",
                    "-e", "OPENROUTER_API_KEY=<your-openrouter-key>",
                    "-e", "CUSTOM_API_URL=http://host.docker.internal:11434/v1",
                    "-e", "CUSTOM_API_KEY=",
                    "-e", "CUSTOM_MODEL_NAME=llama3.2",
                    "-e", "DEFAULT_MODEL=auto",
                    "-e", "OPENAI_ALLOWED_MODELS=o3-mini,o4-mini",
                    "-e", "GOOGLE_ALLOWED_MODELS=flash,pro",
                    "-e", "XAI_ALLOWED_MODELS=grok,grok-3-fast",
                    "-e", "OPENROUTER_ALLOWED_MODELS=opus,sonnet,mistral",
                    "-e", "OPENROUTER_REFERER=https://your-app.com",
                    "-e", "OPENROUTER_TITLE=Your App Name",
                    "-e", "CUSTOM_MODELS_CONFIG_PATH=/path/to/custom_models.json",
                    "-e", "DEFAULT_THINKING_MODE_THINKDEEP=high",
                    "-e", "CONVERSATION_TIMEOUT_HOURS=5",
                    "-e", "MAX_CONVERSATION_TURNS=20",
                    "-e", "LOG_LEVEL=INFO",
                    "-v", "<path_to_your_workspace>:<path_to_your_workspace>",
                    "ghcr.io/patrykiti/zen-mcp-server:latest"
                  ]
                }
              }
            }
            ```

            **Note:** Replace `<path_to_your_workspace>` with the directory where your projects are located.
            This is the directory that MCP server will have access to. Examples:
            - macOS: `/Users/your_username/Documents` or `/Users/your_username/Projects`
            - Linux: `/home/your_username/projects` or `/home/your_username/workspace`
            - Windows: `C:/Users/your_username/Documents` or `C:/Projects`
            
            âš ï¸ **Important:** The path must be the same on both sides of the colon!

            ### Using Docker Compose

            ```bash
            # Clone the repository
            git clone https://github.com/PatrykIti/zen-mcp-server.git
            cd zen-mcp-server

            # Create .env file with your API keys
            cp .env.example .env
            nano .env

            # Start the server
            docker-compose up -d
            ```

            ### Available Tags
            - `ghcr.io/patrykiti/zen-mcp-server:latest` - Always the newest version
            - `ghcr.io/patrykiti/zen-mcp-server:v5.2.4` - Specific version

            For more details, see the [Docker setup guide](docker-compose.yml) in this repository.
DOCKER_SECTION
            echo "Docker section appended to README.md"
            echo "::endgroup::"
            git add README.md
            git commit --amend --no-edit
          else
            echo "::notice::Docker section already exists in README.md"
          fi
          
          # Create summary of changes
          echo "## ðŸ”„ Upstream Sync Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch created:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commits synced:** ${{ steps.check_updates.outputs.commits_behind }}" >> $GITHUB_STEP_SUMMARY
          echo "**Upstream commit:** \`${{ steps.check_updates.outputs.upstream_short }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # List changed files
          echo "### ðŸ“ Changed Files (sample):" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          git diff --name-only origin/main HEAD | head -20 >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          
          # Push the branch
          echo "::group::Pushing branch to origin"
          git push origin $BRANCH_NAME
          echo "::endgroup::"

      - name: Create Pull Request
        if: steps.check_updates.outputs.needs_update == 'true'
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          
          # Get commit messages from upstream
          COMMITS=$(git log --oneline origin/main..upstream/main --pretty=format:"- %s" | head -20)
          
          TITLE="docker: Sync with upstream"
          BODY="## Automated sync with upstream repository

          ### Upstream changes:
          $COMMITS

          ### Merge strategy:
          - All changes from upstream are automatically accepted
          - Protected files are preserved:
            - .github/workflows/auto-version.yml
            - .github/workflows/build_and_publish_docker.yml
            - .github/workflows/sync-upstream.yml
            - docker-compose.yml
            - Dockerfile
          - README.md is updated from upstream with Docker section appended
          - Other workflows from upstream are included (test.yml, etc.)
          - This PR will be automatically merged

          *This is an automated sync that accepts all upstream changes.*"
          
          PR_URL=$(gh pr create \
            --title "$TITLE" \
            --body "$BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "automated,upstream-sync")
          
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

      - name: Auto-merge PR
        if: steps.check_updates.outputs.needs_update == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          
          # Wait a bit for PR checks to initialize
          sleep 10
          
          # Enable auto-merge (squash to keep history clean)
          gh pr merge $PR_NUMBER --auto --squash --delete-branch || {
            # If auto-merge fails, try direct merge
            echo "Auto-merge failed, attempting direct merge..."
            gh pr merge $PR_NUMBER --squash --delete-branch
          }