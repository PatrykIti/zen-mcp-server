name: Sync with Upstream

on:
  schedule:
    - cron: '0 * * * *'  # Every hour
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup remotes and fetch
        run: |
          # Add upstream remote
          git remote add upstream https://github.com/BeehiveInnovations/gemini-mcp-server.git || true
          
          # Fetch all branches and tags
          git fetch --all --tags --prune
          
          # Debug info
          echo "::group::Repository state"
          echo "Current branch: $(git branch --show-current)"
          echo "Remotes:"
          git remote -v
          echo "::endgroup::"

      - name: Check for updates
        id: check_updates
        run: |
          # Make sure we're on main
          git checkout main
          
          # Get latest commits
          UPSTREAM_SHA=$(git rev-parse upstream/main)
          UPSTREAM_SHORT=$(git rev-parse --short upstream/main)
          OUR_SHA=$(git rev-parse HEAD)
          OUR_SHORT=$(git rev-parse --short HEAD)
          
          echo "upstream_sha=$UPSTREAM_SHA" >> $GITHUB_OUTPUT
          echo "upstream_short=$UPSTREAM_SHORT" >> $GITHUB_OUTPUT
          echo "our_sha=$OUR_SHA" >> $GITHUB_OUTPUT
          echo "our_short=$OUR_SHORT" >> $GITHUB_OUTPUT
          
          # Check if upstream is ancestor of our main (meaning we're up to date)
          if git merge-base --is-ancestor upstream/main HEAD; then
            echo "needs_update=false" >> $GITHUB_OUTPUT
            
            echo "## âœ… Repository is up-to-date with upstream" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current commit:** \`$OUR_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "**Upstream commit:** \`$UPSTREAM_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No synchronization needed. The fork is already synchronized with the upstream repository." >> $GITHUB_STEP_SUMMARY
          else
            echo "needs_update=true" >> $GITHUB_OUTPUT
            
            # Count commits behind/ahead
            COMMITS_BEHIND=$(git rev-list --count HEAD..upstream/main)
            COMMITS_AHEAD=$(git rev-list --count upstream/main..HEAD)
            
            echo "commits_behind=$COMMITS_BEHIND" >> $GITHUB_OUTPUT
            echo "commits_ahead=$COMMITS_AHEAD" >> $GITHUB_OUTPUT
            
            echo "::notice::Repository is $COMMITS_AHEAD commits ahead and $COMMITS_BEHIND commits behind upstream"
            
            echo "::group::Commits to sync from upstream"
            git log --oneline HEAD..upstream/main | head -10
            echo "::endgroup::"
            
            echo "::group::Our commits not in upstream"
            git log --oneline upstream/main..HEAD | head -10
            echo "::endgroup::"
          fi

      - name: Create sync branch
        if: steps.check_updates.outputs.needs_update == 'true'
        id: create_branch
        run: |
          # Generate unique branch name
          BRANCH_NAME="sync/upstream-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          echo "::group::Creating sync branch"
          # Create new branch from current main
          git checkout -b $BRANCH_NAME main
          echo "Created branch: $BRANCH_NAME"
          echo "Starting point: $(git rev-parse --short HEAD)"
          echo "::endgroup::"

      - name: Backup protected files
        if: steps.check_updates.outputs.needs_update == 'true'
        run: |
          echo "::group::Backing up protected files"
          mkdir -p /tmp/protected_files
          
          # List of protected files
          PROTECTED_FILES=(
            ".github/workflows/auto-version.yml"
            ".github/workflows/build_and_publish_docker.yml"
            ".github/workflows/sync-upstream.yml"
            "docker-compose.yml"
            "Dockerfile"
          )
          
          for file in "${PROTECTED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "Backing up $file"
              mkdir -p "/tmp/protected_files/$(dirname "$file")"
              cp "$file" "/tmp/protected_files/$file"
            fi
          done
          echo "::endgroup::"

      - name: Merge upstream changes
        if: steps.check_updates.outputs.needs_update == 'true'
        id: merge_upstream
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          
          echo "::group::Merging upstream changes"
          
          # Try to merge upstream/main
          if git merge upstream/main --no-edit; then
            echo "Merge successful without conflicts"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "Merge conflicts detected, resolving..."
            
            # List conflicts
            echo "Conflicted files:"
            git status --porcelain | grep "^UU" | awk '{print $2}'
            
            # Resolve conflicts: keep theirs for most files, ours for protected files
            git status --porcelain | grep "^UU" | awk '{print $2}' | while read file; do
              case "$file" in
                .github/workflows/auto-version.yml|\
                .github/workflows/build_and_publish_docker.yml|\
                .github/workflows/sync-upstream.yml|\
                docker-compose.yml|\
                Dockerfile)
                  echo "Keeping our version of $file"
                  git checkout --ours "$file"
                  ;;
                *)
                  echo "Accepting upstream version of $file"
                  git checkout --theirs "$file"
                  ;;
              esac
              git add "$file"
            done
            
            # Complete the merge
            git commit --no-edit
            echo "Merge completed with conflict resolution"
            echo "success=true" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Restore protected files
        if: steps.check_updates.outputs.needs_update == 'true' && steps.merge_upstream.outputs.success == 'true'
        run: |
          echo "::group::Restoring protected files"
          
          PROTECTED_FILES=(
            ".github/workflows/auto-version.yml"
            ".github/workflows/build_and_publish_docker.yml"
            ".github/workflows/sync-upstream.yml"
            "docker-compose.yml"
            "Dockerfile"
          )
          
          CHANGES_MADE=false
          
          for file in "${PROTECTED_FILES[@]}"; do
            if [ -f "/tmp/protected_files/$file" ]; then
              if ! cmp -s "/tmp/protected_files/$file" "$file" 2>/dev/null; then
                echo "Restoring protected file: $file"
                mkdir -p "$(dirname "$file")"
                cp "/tmp/protected_files/$file" "$file"
                git add "$file"
                CHANGES_MADE=true
              fi
            fi
          done
          
          # Commit restored files if any changes were made
          if [ "$CHANGES_MADE" = true ]; then
            git commit -m "Restore protected Docker files after upstream merge"
          fi
          
          echo "::endgroup::"

      - name: Update README with Docker section
        if: steps.check_updates.outputs.needs_update == 'true' && steps.merge_upstream.outputs.success == 'true'
        run: |
          if ! grep -q "## Docker Image Usage (Fork Enhancement)" README.md; then
            echo "::group::Adding Docker section to README"
            {
              echo ""
              echo "## Docker Image Usage (Fork Enhancement)"
              echo ""
              echo "This fork maintains Docker support with pre-built images available at GitHub Container Registry."
              echo ""
              echo "### Quick Start with Docker"
              echo ""
              echo "**Basic Configuration (Gemini only):**"
              echo '```json'
              echo '{'
              echo '  "mcpServers": {'
              echo '    "zen": {'
              echo '      "command": "docker",'
              echo '      "args": ['
              echo '        "run", "--rm", "-i",'
              echo '        "-e", "GEMINI_API_KEY=<your_api_key_from_google_ai_studio>",'
              echo '        "-v", "<path_to_your_workspace>:<path_to_your_workspace>",'
              echo '        "ghcr.io/patrykiti/zen-mcp-server:latest"'
              echo '      ]'
              echo '    }'
              echo '  }'
              echo '}'
              echo '```'
              echo ""
              echo "**Full Configuration (All Providers):**"
              echo '```json'
              echo '{'
              echo '  "mcpServers": {'
              echo '    "zen": {'
              echo '      "command": "docker",'
              echo '      "args": ['
              echo '        "run", "--rm", "-i",'
              echo '        "-e", "GEMINI_API_KEY=<your-gemini-key>",'
              echo '        "-e", "OPENAI_API_KEY=<your-openai-key>",'
              echo '        "-e", "XAI_API_KEY=<your-xai-key>",'
              echo '        "-e", "OPENROUTER_API_KEY=<your-openrouter-key>",'
              echo '        "-e", "CUSTOM_API_URL=http://host.docker.internal:11434/v1",'
              echo '        "-e", "CUSTOM_API_KEY=",'
              echo '        "-e", "CUSTOM_MODEL_NAME=llama3.2",'
              echo '        "-e", "DEFAULT_MODEL=auto",'
              echo '        "-e", "OPENAI_ALLOWED_MODELS=o3-mini,o4-mini",'
              echo '        "-e", "GOOGLE_ALLOWED_MODELS=flash,pro",'
              echo '        "-e", "XAI_ALLOWED_MODELS=grok,grok-3-fast",'
              echo '        "-e", "OPENROUTER_ALLOWED_MODELS=opus,sonnet,mistral",'
              echo '        "-e", "OPENROUTER_REFERER=https://your-app.com",'
              echo '        "-e", "OPENROUTER_TITLE=Your App Name",'
              echo '        "-e", "CUSTOM_MODELS_CONFIG_PATH=/path/to/custom_models.json",'
              echo '        "-e", "DEFAULT_THINKING_MODE_THINKDEEP=high",'
              echo '        "-e", "CONVERSATION_TIMEOUT_HOURS=5",'
              echo '        "-e", "MAX_CONVERSATION_TURNS=20",'
              echo '        "-e", "LOG_LEVEL=INFO",'
              echo '        "-v", "<path_to_your_workspace>:<path_to_your_workspace>",'
              echo '        "ghcr.io/patrykiti/zen-mcp-server:latest"'
              echo '      ]'
              echo '    }'
              echo '  }'
              echo '}'
              echo '```'
              echo ""
              echo "**Note:** Replace \`<path_to_your_workspace>\` with the directory where your projects are located."
              echo ""
              echo "### Using Docker Compose"
              echo ""
              echo '```bash'
              echo "git clone https://github.com/PatrykIti/zen-mcp-server.git"
              echo "cd zen-mcp-server"
              echo "cp .env.example .env"
              echo "nano .env"
              echo "docker-compose up -d"
              echo '```'
              echo ""
              echo "### Available Tags"
              echo "- \`ghcr.io/patrykiti/zen-mcp-server:latest\` - Always the newest version"
              echo "- \`ghcr.io/patrykiti/zen-mcp-server:v5.2.4\` - Specific version"
              echo ""
              echo "For more details, see the [Docker setup guide](docker-compose.yml) in this repository."
            } >> README.md
            
            git add README.md
            git commit -m "Add Docker usage section to README"
            echo "::endgroup::"
          fi

      - name: Push branch and create PR
        if: steps.check_updates.outputs.needs_update == 'true' && steps.merge_upstream.outputs.success == 'true'
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.PAT2 }}
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          
          echo "::group::Final verification"
          echo "Current branch: $(git branch --show-current)"
          echo "Commits in this branch not in main:"
          git log --oneline main..HEAD
          echo "::endgroup::"
          
          # Push branch
          echo "::group::Pushing branch"
          git push origin $BRANCH_NAME
          echo "::endgroup::"
          
          # Create PR
          echo "::group::Creating Pull Request"
          
          # Get the merge commit message
          MERGE_COMMIT=$(git log -1 --pretty=format:"%s")
          
          TITLE="docker: Sync with upstream (merge)"
          BODY="## Automated sync with upstream repository

          ### Merge details:
          - Merged upstream/main into our fork
          - Protected Docker-related files were preserved
          - README.md updated with Docker section if needed

          ### Protected files (preserved):
          - .github/workflows/auto-version.yml
          - .github/workflows/build_and_publish_docker.yml  
          - .github/workflows/sync-upstream.yml
          - docker-compose.yml
          - Dockerfile

          **Upstream commit:** \`${{ steps.check_updates.outputs.upstream_short }}\`
          **Our base commit:** \`${{ steps.check_updates.outputs.our_short }}\`

          **Merge commit:** $MERGE_COMMIT

          *This PR uses git merge to properly maintain fork relationship with upstream while preserving our custom changes.*"
          
          PR_URL=$(gh pr create \
            --title "$TITLE" \
            --body "$BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --repo ${{ github.repository }})
          
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          echo "Pull request created: #$PR_NUMBER"
          echo "::endgroup::"

      - name: Auto-merge PR
        if: steps.check_updates.outputs.needs_update == 'true' && steps.create_pr.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.PAT2 }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          
          echo "Waiting for PR checks to initialize..."
          sleep 15
          
          # Check if PR exists first
          echo "Verifying PR #$PR_NUMBER exists..."
          if ! gh pr view $PR_NUMBER --repo ${{ github.repository }} >/dev/null 2>&1; then
            echo "Error: PR #$PR_NUMBER does not exist or cannot be accessed"
            echo "Available PRs:"
            gh pr list --repo ${{ github.repository }} --state open
            exit 1
          fi
          
          # Check PR status
          PR_STATE=$(gh pr view $PR_NUMBER --repo ${{ github.repository }} --json state --jq '.state')
          echo "PR #$PR_NUMBER state: $PR_STATE"
          
          if [ "$PR_STATE" = "OPEN" ]; then
            # Enable auto-merge
            echo "Enabling auto-merge for PR #$PR_NUMBER"
            if gh pr merge $PR_NUMBER --auto --squash --delete-branch --repo ${{ github.repository }}; then
              echo "Auto-merge enabled successfully"
            else
              echo "Auto-merge failed, attempting direct merge..."
              sleep 5
              
              # Check if there are any status checks blocking the merge
              echo "Checking merge requirements..."
              gh pr view $PR_NUMBER --repo ${{ github.repository }} --json mergeable,mergeStateStatus
              
              # Try direct merge
              if gh pr merge $PR_NUMBER --squash --delete-branch --repo ${{ github.repository }}; then
                echo "Direct merge successful"
              else
                echo "Direct merge also failed. PR may have conflicts or protection rules."
                echo "PR will remain open for manual review."
              fi
            fi
          else
            echo "PR is not in OPEN state (current: $PR_STATE). Skipping merge."
          fi
