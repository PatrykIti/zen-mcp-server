name: Sync with Upstream

on:
  schedule:
    - cron: '0 * * * *'  # Every hour
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/BeehiveInnovations/gemini-mcp-server.git || true
          git fetch upstream

      - name: Check for updates
        id: check_updates
        run: |
          # Get latest commit from upstream
          UPSTREAM_SHA=$(git rev-parse upstream/main)
          UPSTREAM_SHORT=$(git rev-parse --short upstream/main)
          
          # Get latest commit from our main
          OUR_SHA=$(git rev-parse origin/main)
          OUR_SHORT=$(git rev-parse --short origin/main)
          
          echo "upstream_sha=$UPSTREAM_SHA" >> $GITHUB_OUTPUT
          echo "upstream_short=$UPSTREAM_SHORT" >> $GITHUB_OUTPUT
          echo "our_sha=$OUR_SHA" >> $GITHUB_OUTPUT
          echo "our_short=$OUR_SHORT" >> $GITHUB_OUTPUT
          
          # Count commits behind upstream
          COMMITS_BEHIND=$(git rev-list --count origin/main..upstream/main)
          echo "commits_behind=$COMMITS_BEHIND" >> $GITHUB_OUTPUT
          
          if [ "$COMMITS_BEHIND" -eq 0 ]; then
            echo "needs_update=false" >> $GITHUB_OUTPUT
            
            # Create nice summary for up-to-date status
            echo "## ‚úÖ Repository is up-to-date with upstream" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current commit:** \`$OUR_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "**Upstream commit:** \`$UPSTREAM_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No synchronization needed. The fork is already synchronized with the upstream repository." >> $GITHUB_STEP_SUMMARY
            
            echo "::notice title=Up-to-date::Repository is already synchronized with upstream (commit: $OUR_SHORT)"
          else
            echo "needs_update=true" >> $GITHUB_OUTPUT
            echo "::notice title=Updates Available::Found $COMMITS_BEHIND new commits from upstream"
          fi

      - name: Create sync branch and merge
        if: steps.check_updates.outputs.needs_update == 'true'
        id: create_branch
        run: |
          echo "::group::Creating sync branch"
          # Generate unique branch name
          BRANCH_NAME="sync/upstream-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Create and checkout new branch from main
          git checkout -b $BRANCH_NAME origin/main
          echo "Created branch: $BRANCH_NAME"
          echo "::endgroup::"
          
          echo "::group::Backing up protected files"
          # Create temp directory for backups
          mkdir -p /tmp/protected_files/.github/workflows
          
          # Save our protected files
          cp .github/workflows/auto-version.yml /tmp/protected_files/.github/workflows/ 2>/dev/null || true
          cp .github/workflows/build_and_publish_docker.yml /tmp/protected_files/.github/workflows/ 2>/dev/null || true
          cp .github/workflows/sync-upstream.yml /tmp/protected_files/.github/workflows/ 2>/dev/null || true
          cp docker-compose.yml /tmp/protected_files/ 2>/dev/null || true
          cp Dockerfile /tmp/protected_files/ 2>/dev/null || true
          echo "::endgroup::"
          
          echo "::group::Merging upstream changes"
          # First try a simple merge
          if git merge upstream/main --no-edit --no-ff; then
            echo "‚úÖ Simple merge successful"
          else
            echo "‚ö†Ô∏è Merge conflicts detected, resolving..."
            
            # Reset to start fresh
            git merge --abort 2>/dev/null || true
            
            # Use more aggressive merge strategy
            git merge upstream/main --no-edit --strategy-option=theirs --allow-unrelated-histories || {
              echo "Standard merge failed, using reset approach..."
              
              # Force merge by taking upstream completely then restoring our files
              git reset --hard upstream/main
              echo "Reset to upstream/main"
            }
          fi
          echo "::endgroup::"
          
          echo "::group::Restoring protected files"
          # Restore our protected files
          cp /tmp/protected_files/.github/workflows/auto-version.yml .github/workflows/ 2>/dev/null || true
          cp /tmp/protected_files/.github/workflows/build_and_publish_docker.yml .github/workflows/ 2>/dev/null || true
          cp /tmp/protected_files/.github/workflows/sync-upstream.yml .github/workflows/ 2>/dev/null || true
          cp /tmp/protected_files/docker-compose.yml . 2>/dev/null || true
          cp /tmp/protected_files/Dockerfile . 2>/dev/null || true
          
          # Stage the restored files
          git add .github/workflows/auto-version.yml .github/workflows/build_and_publish_docker.yml .github/workflows/sync-upstream.yml docker-compose.yml Dockerfile 2>/dev/null || true
          echo "::endgroup::"
          
          # Append Docker usage section to README if it doesn't exist
          if ! grep -q "## Docker Image Usage (Fork Enhancement)" README.md; then
            echo "::group::Appending Docker section to README"
            
            # Create Docker section using echo commands
            {
              echo ""
              echo "## Docker Image Usage (Fork Enhancement)"
              echo ""
              echo "This fork maintains Docker support with pre-built images available at GitHub Container Registry."
              echo ""
              echo "### Quick Start with Docker"
              echo ""
              echo "**Basic Configuration (Gemini only):**"
              echo '```json'
              echo '{'
              echo '  "mcpServers": {'
              echo '    "zen": {'
              echo '      "command": "docker",'
              echo '      "args": ['
              echo '        "run", "--rm", "-i",'
              echo '        "-e", "GEMINI_API_KEY=<your_api_key_from_google_ai_studio>",'
              echo '        "-v", "<path_to_your_workspace>:<path_to_your_workspace>",'
              echo '        "ghcr.io/patrykiti/zen-mcp-server:latest"'
              echo '      ]'
              echo '    }'
              echo '  }'
              echo '}'
              echo '```'
              echo ""
              echo "**Full Configuration (All Providers):**"
              echo '```json'
              echo '{'
              echo '  "mcpServers": {'
              echo '    "zen": {'
              echo '      "command": "docker",'
              echo '      "args": ['
              echo '        "run", "--rm", "-i",'
              echo '        "-e", "GEMINI_API_KEY=<your-gemini-key>",'
              echo '        "-e", "OPENAI_API_KEY=<your-openai-key>",'
              echo '        "-e", "XAI_API_KEY=<your-xai-key>",'
              echo '        "-e", "OPENROUTER_API_KEY=<your-openrouter-key>",'
              echo '        "-e", "CUSTOM_API_URL=http://host.docker.internal:11434/v1",'
              echo '        "-e", "CUSTOM_API_KEY=",'
              echo '        "-e", "CUSTOM_MODEL_NAME=llama3.2",'
              echo '        "-e", "DEFAULT_MODEL=auto",'
              echo '        "-e", "OPENAI_ALLOWED_MODELS=o3-mini,o4-mini",'
              echo '        "-e", "GOOGLE_ALLOWED_MODELS=flash,pro",'
              echo '        "-e", "XAI_ALLOWED_MODELS=grok,grok-3-fast",'
              echo '        "-e", "OPENROUTER_ALLOWED_MODELS=opus,sonnet,mistral",'
              echo '        "-e", "OPENROUTER_REFERER=https://your-app.com",'
              echo '        "-e", "OPENROUTER_TITLE=Your App Name",'
              echo '        "-e", "CUSTOM_MODELS_CONFIG_PATH=/path/to/custom_models.json",'
              echo '        "-e", "DEFAULT_THINKING_MODE_THINKDEEP=high",'
              echo '        "-e", "CONVERSATION_TIMEOUT_HOURS=5",'
              echo '        "-e", "MAX_CONVERSATION_TURNS=20",'
              echo '        "-e", "LOG_LEVEL=INFO",'
              echo '        "-v", "<path_to_your_workspace>:<path_to_your_workspace>",'
              echo '        "ghcr.io/patrykiti/zen-mcp-server:latest"'
              echo '      ]'
              echo '    }'
              echo '  }'
              echo '}'
              echo '```'
              echo ""
              echo "**Note:** Replace \`<path_to_your_workspace>\` with the directory where your projects are located."
              echo "This is the directory that MCP server will have access to. Examples:"
              echo "- macOS: \`/Users/your_username/Documents\` or \`/Users/your_username/Projects\`"
              echo "- Linux: \`/home/your_username/projects\` or \`/home/your_username/workspace\`"
              echo "- Windows: \`C:/Users/your_username/Documents\` or \`C:/Projects\`"
              echo ""
              echo "‚ö†Ô∏è **Important:** The path must be the same on both sides of the colon!"
              echo ""
              echo "### Using Docker Compose"
              echo ""
              echo '```bash'
              echo "# Clone the repository"
              echo "git clone https://github.com/PatrykIti/zen-mcp-server.git"
              echo "cd zen-mcp-server"
              echo ""
              echo "# Create .env file with your API keys"
              echo "cp .env.example .env"
              echo "nano .env"
              echo ""
              echo "# Start the server"
              echo "docker-compose up -d"
              echo '```'
              echo ""
              echo "### Available Tags"
              echo "- \`ghcr.io/patrykiti/zen-mcp-server:latest\` - Always the newest version"
              echo "- \`ghcr.io/patrykiti/zen-mcp-server:v5.2.4\` - Specific version"
              echo ""
              echo "For more details, see the [Docker setup guide](docker-compose.yml) in this repository."
            } >> README.md
            
            echo "Docker section appended to README.md"
            git add README.md
            echo "::endgroup::"
          else
            echo "::notice::Docker section already exists in README.md"
          fi
          
          # Check if we have any changes to commit
          if git diff --cached --quiet && git diff --quiet; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "::warning::No changes detected after merge and file restoration"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            
            # Commit all changes
            git commit -m "feat: sync with upstream

            - Merged ${{ steps.check_updates.outputs.commits_behind }} commits from upstream
            - Preserved protected files (workflows, docker configs)
            - Updated README with Docker section

            Upstream commit: ${{ steps.check_updates.outputs.upstream_short }}"
            
            # Create summary of changes
            echo "## üîÑ Upstream Sync Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Branch created:** \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
            echo "**Commits synced:** ${{ steps.check_updates.outputs.commits_behind }}" >> $GITHUB_STEP_SUMMARY
            echo "**Upstream commit:** \`${{ steps.check_updates.outputs.upstream_short }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List changed files
            echo "### üìù Changed Files:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            git diff --name-only origin/main HEAD | head -20 >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            
            # Push the branch
            echo "::group::Pushing branch to origin"
            git push origin $BRANCH_NAME
            echo "::endgroup::"
          fi

      - name: Create Pull Request
        if: steps.check_updates.outputs.needs_update == 'true' && steps.create_branch.outputs.has_changes == 'true'
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.PAT2 }}
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          
          # Verify branch exists and has commits
          if ! git show-ref --verify --quiet refs/heads/$BRANCH_NAME; then
            echo "::error::Branch $BRANCH_NAME does not exist"
            exit 1
          fi
          
          # Check if branch has commits different from main
          COMMIT_COUNT=$(git rev-list --count origin/main..HEAD)
          if [ "$COMMIT_COUNT" -eq 0 ]; then
            echo "::error::Branch has no commits different from main"
            exit 1
          fi
          
          # Get commit messages from the changes we made
          COMMITS=$(git log --oneline origin/main..HEAD --pretty=format:"- %s")
          
          TITLE="feat: sync with upstream (${{ steps.check_updates.outputs.commits_behind }} commits)"
          BODY="## Automated sync with upstream repository

          ### Changes in this sync:
          $COMMITS

          ### Merge strategy:
          - All changes from upstream are automatically accepted
          - Protected files are preserved:
            - .github/workflows/auto-version.yml
            - .github/workflows/build_and_publish_docker.yml
            - .github/workflows/sync-upstream.yml
            - docker-compose.yml
            - Dockerfile
          - README.md is updated from upstream with Docker section appended
          - Other workflows from upstream are included (test.yml, etc.)

          ### Upstream commits included:
          $(git log --oneline origin/main..upstream/main --pretty=format:"- %s" | head -10)

          *This is an automated sync that accepts all upstream changes while preserving our Docker enhancements.*"
          
          # Create PR using gh CLI
          PR_URL=$(gh pr create \
            --title "$TITLE" \
            --body "$BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "automated, upstream-sync")
          
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          echo "::notice title=PR Created::Pull Request #$PR_NUMBER created: $PR_URL"

      - name: Auto-merge PR
        if: steps.check_updates.outputs.needs_update == 'true' && steps.create_branch.outputs.has_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          
          # Wait a bit for PR checks to initialize
          sleep 30
          
          # Enable auto-merge (squash to keep history clean)
          echo "::group::Enabling auto-merge"
          if gh pr merge $PR_NUMBER --auto --squash --delete-branch; then
            echo "‚úÖ Auto-merge enabled successfully"
          else
            echo "‚ö†Ô∏è Auto-merge failed, attempting direct merge..."
            sleep 10
            if gh pr merge $PR_NUMBER --squash --delete-branch; then
              echo "‚úÖ Direct merge successful"
            else
              echo "::error::Both auto-merge and direct merge failed"
              # Don't fail the workflow, just report the issue
              echo "::warning::PR created but could not be automatically merged. Manual intervention required."
            fi
          fi
          echo "::endgroup::"

      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.check_updates.outputs.needs_update }}" == "false" ]; then
            echo "::notice title=No Action Needed::Repository is up-to-date with upstream"
          elif [ "${{ steps.create_branch.outputs.has_changes }}" == "false" ]; then
            echo "::warning title=No Changes::Upstream had updates but no actual changes after merge"
          elif [ "${{ steps.create_pr.outputs.pr_number }}" != "" ]; then
            echo "::notice title=Sync Complete::Successfully synced with upstream via PR #${{ steps.create_pr.outputs.pr_number }}"
          else
            echo "::error title=Sync Failed::Could not complete sync process"
          fi
