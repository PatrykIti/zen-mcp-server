name: Sync with Upstream

on:
  schedule:
    - cron: '0 * * * *'  # Every hour
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup remotes and fetch
        run: |
          # Add upstream remote
          git remote add upstream https://github.com/BeehiveInnovations/gemini-mcp-server.git || true
          
          # Fetch all branches and tags
          git fetch --all --tags --prune
          
          # Debug info
          echo "::group::Repository state"
          echo "Current branch: $(git branch --show-current)"
          echo "Remotes:"
          git remote -v
          echo "::endgroup::"

      - name: Check for updates
        id: check_updates
        run: |
          # Make sure we're on main
          git checkout main
          
          # Get latest commits
          UPSTREAM_SHA=$(git rev-parse upstream/main)
          UPSTREAM_SHORT=$(git rev-parse --short upstream/main)
          OUR_SHA=$(git rev-parse HEAD)
          OUR_SHORT=$(git rev-parse --short HEAD)
          
          echo "upstream_sha=$UPSTREAM_SHA" >> $GITHUB_OUTPUT
          echo "upstream_short=$UPSTREAM_SHORT" >> $GITHUB_OUTPUT
          echo "our_sha=$OUR_SHA" >> $GITHUB_OUTPUT
          echo "our_short=$OUR_SHORT" >> $GITHUB_OUTPUT
          
          # Check divergence
          COMMITS_BEHIND=$(git rev-list --count HEAD..upstream/main)
          COMMITS_AHEAD=$(git rev-list --count upstream/main..HEAD)
          
          echo "commits_behind=$COMMITS_BEHIND" >> $GITHUB_OUTPUT
          echo "commits_ahead=$COMMITS_AHEAD" >> $GITHUB_OUTPUT
          
          echo "::notice::Repository is $COMMITS_AHEAD commits ahead and $COMMITS_BEHIND commits behind upstream"
          
          if [ "$COMMITS_BEHIND" -eq 0 ]; then
            echo "needs_update=false" >> $GITHUB_OUTPUT
            
            echo "## âœ… Repository is up-to-date with upstream" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Current commit:** \`$OUR_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "**Upstream commit:** \`$UPSTREAM_SHORT\`" >> $GITHUB_STEP_SUMMARY
            echo "**Commits ahead:** $COMMITS_AHEAD" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No synchronization needed. The fork is already synchronized with the upstream repository." >> $GITHUB_STEP_SUMMARY
          else
            echo "needs_update=true" >> $GITHUB_OUTPUT
            
            echo "::group::Commits to sync from upstream"
            git log --oneline HEAD..upstream/main | head -10
            echo "::endgroup::"
            
            echo "::group::Our commits not in upstream"
            git log --oneline upstream/main..HEAD | head -10
            echo "::endgroup::"
          fi

      - name: Create sync branch
        if: steps.check_updates.outputs.needs_update == 'true'
        id: create_branch
        run: |
          # Generate unique branch name
          BRANCH_NAME="sync/upstream-$(date +%Y%m%d-%H%M%S)"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          echo "::group::Creating sync branch"
          # Create new branch from current main
          git checkout -b $BRANCH_NAME main
          echo "Created branch: $BRANCH_NAME"
          echo "Starting point: $(git rev-parse --short HEAD)"
          echo "::endgroup::"

      - name: Cherry-pick upstream changes
        if: steps.check_updates.outputs.needs_update == 'true'
        id: cherry_pick
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          
          echo "::group::Cherry-picking upstream commits"
          # Get list of commits to cherry-pick (in reverse order for correct application)
          COMMITS_TO_PICK=$(git rev-list --reverse HEAD..upstream/main)
          
          if [ -z "$COMMITS_TO_PICK" ]; then
            echo "No commits to cherry-pick"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Save protected files
          echo "Backing up protected files..."
          mkdir -p /tmp/protected_files
          cp .github/workflows/auto-version.yml /tmp/protected_files/ 2>/dev/null || true
          cp .github/workflows/build_and_publish_docker.yml /tmp/protected_files/ 2>/dev/null || true
          cp .github/workflows/sync-upstream.yml /tmp/protected_files/ 2>/dev/null || true
          cp docker-compose.yml /tmp/protected_files/ 2>/dev/null || true
          cp Dockerfile /tmp/protected_files/ 2>/dev/null || true
          
          # Cherry-pick each commit
          PICKED_COUNT=0
          for commit in $COMMITS_TO_PICK; do
            echo "Cherry-picking $commit..."
            if git cherry-pick $commit --strategy-option=theirs; then
              PICKED_COUNT=$((PICKED_COUNT + 1))
            else
              echo "Cherry-pick failed for $commit, trying to resolve..."
              
              # Accept theirs for all conflicts except protected files
              git status --porcelain | grep "^UU" | awk '{print $2}' | while read file; do
                case "$file" in
                  .github/workflows/auto-version.yml|\
                  .github/workflows/build_and_publish_docker.yml|\
                  .github/workflows/sync-upstream.yml|\
                  docker-compose.yml|\
                  Dockerfile)
                    echo "Keeping our version of $file"
                    git checkout --ours "$file"
                    ;;
                  *)
                    echo "Accepting upstream version of $file"
                    git checkout --theirs "$file"
                    ;;
                esac
                git add "$file"
              done
              
              # Continue cherry-pick
              git cherry-pick --continue --no-edit || {
                echo "Failed to resolve cherry-pick for $commit"
                git cherry-pick --abort
                break
              }
              PICKED_COUNT=$((PICKED_COUNT + 1))
            fi
          done
          
          echo "Cherry-picked $PICKED_COUNT commits"
          echo "picked_count=$PICKED_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$PICKED_COUNT" -gt 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            
            # Restore protected files if they were changed
            cp /tmp/protected_files/auto-version.yml .github/workflows/ 2>/dev/null || true
            cp /tmp/protected_files/build_and_publish_docker.yml .github/workflows/ 2>/dev/null || true
            cp /tmp/protected_files/sync-upstream.yml .github/workflows/ 2>/dev/null || true
            cp /tmp/protected_files/docker-compose.yml . 2>/dev/null || true
            cp /tmp/protected_files/Dockerfile . 2>/dev/null || true
            
            # Commit if there are changes to protected files
            if ! git diff --quiet; then
              git add -A
              git commit -m "Restore protected Docker files after upstream sync"
            fi
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: Update README with Docker section
        if: steps.check_updates.outputs.needs_update == 'true' && steps.cherry_pick.outputs.success == 'true'
        run: |
          if ! grep -q "## Docker Image Usage (Fork Enhancement)" README.md; then
            echo "::group::Adding Docker section to README"
            {
              echo ""
              echo "## Docker Image Usage (Fork Enhancement)"
              echo ""
              echo "This fork maintains Docker support with pre-built images available at GitHub Container Registry."
              echo ""
              echo "### Quick Start with Docker"
              echo ""
              echo "**Basic Configuration (Gemini only):**"
              echo '```json'
              echo '{'
              echo '  "mcpServers": {'
              echo '    "zen": {'
              echo '      "command": "docker",'
              echo '      "args": ['
              echo '        "run", "--rm", "-i",'
              echo '        "-e", "GEMINI_API_KEY=<your_api_key_from_google_ai_studio>",'
              echo '        "-v", "<path_to_your_workspace>:<path_to_your_workspace>",'
              echo '        "ghcr.io/patrykiti/zen-mcp-server:latest"'
              echo '      ]'
              echo '    }'
              echo '  }'
              echo '}'
              echo '```'
              echo ""
              echo "**Full Configuration (All Providers):**"
              echo '```json'
              echo '{'
              echo '  "mcpServers": {'
              echo '    "zen": {'
              echo '      "command": "docker",'
              echo '      "args": ['
              echo '        "run", "--rm", "-i",'
              echo '        "-e", "GEMINI_API_KEY=<your-gemini-key>",'
              echo '        "-e", "OPENAI_API_KEY=<your-openai-key>",'
              echo '        "-e", "XAI_API_KEY=<your-xai-key>",'
              echo '        "-e", "OPENROUTER_API_KEY=<your-openrouter-key>",'
              echo '        "-e", "CUSTOM_API_URL=http://host.docker.internal:11434/v1",'
              echo '        "-e", "CUSTOM_API_KEY=",'
              echo '        "-e", "CUSTOM_MODEL_NAME=llama3.2",'
              echo '        "-e", "DEFAULT_MODEL=auto",'
              echo '        "-e", "OPENAI_ALLOWED_MODELS=o3-mini,o4-mini",'
              echo '        "-e", "GOOGLE_ALLOWED_MODELS=flash,pro",'
              echo '        "-e", "XAI_ALLOWED_MODELS=grok,grok-3-fast",'
              echo '        "-e", "OPENROUTER_ALLOWED_MODELS=opus,sonnet,mistral",'
              echo '        "-e", "OPENROUTER_REFERER=https://your-app.com",'
              echo '        "-e", "OPENROUTER_TITLE=Your App Name",'
              echo '        "-e", "CUSTOM_MODELS_CONFIG_PATH=/path/to/custom_models.json",'
              echo '        "-e", "DEFAULT_THINKING_MODE_THINKDEEP=high",'
              echo '        "-e", "CONVERSATION_TIMEOUT_HOURS=5",'
              echo '        "-e", "MAX_CONVERSATION_TURNS=20",'
              echo '        "-e", "LOG_LEVEL=INFO",'
              echo '        "-v", "<path_to_your_workspace>:<path_to_your_workspace>",'
              echo '        "ghcr.io/patrykiti/zen-mcp-server:latest"'
              echo '      ]'
              echo '    }'
              echo '  }'
              echo '}'
              echo '```'
              echo ""
              echo "**Note:** Replace \`<path_to_your_workspace>\` with the directory where your projects are located."
              echo ""
              echo "### Using Docker Compose"
              echo ""
              echo '```bash'
              echo "git clone https://github.com/PatrykIti/zen-mcp-server.git"
              echo "cd zen-mcp-server"
              echo "cp .env.example .env"
              echo "nano .env"
              echo "docker-compose up -d"
              echo '```'
              echo ""
              echo "### Available Tags"
              echo "- \`ghcr.io/patrykiti/zen-mcp-server:latest\` - Always the newest version"
              echo "- \`ghcr.io/patrykiti/zen-mcp-server:v5.2.4\` - Specific version"
              echo ""
              echo "For more details, see the [Docker setup guide](docker-compose.yml) in this repository."
            } >> README.md
            
            git add README.md
            git commit -m "Add Docker usage section to README"
            echo "::endgroup::"
          fi

      - name: Push branch and create PR
        if: steps.check_updates.outputs.needs_update == 'true' && steps.cherry_pick.outputs.success == 'true'
        id: create_pr
        env:
          GITHUB_TOKEN: ${{ secrets.PAT2 }}
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          
          echo "::group::Final verification"
          echo "Current branch: $(git branch --show-current)"
          echo "Commits in this branch not in main:"
          git log --oneline main..HEAD
          echo "::endgroup::"
          
          # Push branch
          echo "::group::Pushing branch"
          git push origin $BRANCH_NAME
          echo "::endgroup::"
          
          # Create PR
          echo "::group::Creating Pull Request"
          
          # Get the new commits
          COMMITS=$(git log --oneline main..HEAD --pretty=format:"- %s")
          
          TITLE="docker: Sync with upstream (cherry-pick)"
          BODY="## Automated sync with upstream repository

          ### Cherry-picked commits from upstream:
          $COMMITS

          ### Sync details:
          - Repository was ${{ steps.check_updates.outputs.commits_ahead }} commits ahead and ${{ steps.check_updates.outputs.commits_behind }} commits behind upstream
          - Cherry-picked ${{ steps.cherry_pick.outputs.picked_count }} commits from upstream
          - Protected Docker-related files were preserved
          - README.md updated with Docker section if needed

          ### Protected files (preserved):
          - .github/workflows/auto-version.yml
          - .github/workflows/build_and_publish_docker.yml  
          - .github/workflows/sync-upstream.yml
          - docker-compose.yml
          - Dockerfile

          **Upstream commit:** \`${{ steps.check_updates.outputs.upstream_short }}\`
          **Our base commit:** \`${{ steps.check_updates.outputs.our_short }}\`

          *This PR uses cherry-pick to apply only the new upstream commits while preserving our custom changes.*"
          
          PR_URL=$(gh pr create \
            --title "$TITLE" \
            --body "$BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --repo ${{ github.repository }})
          
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          
          # Extract PR number
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          
          echo "Pull request created: #$PR_NUMBER"
          echo "::endgroup::"

      - name: Auto-merge PR
        if: steps.check_updates.outputs.needs_update == 'true' && steps.create_pr.outputs.pr_number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          
          echo "Waiting for PR checks to initialize..."
          sleep 10
          
          # Enable auto-merge
          echo "Enabling auto-merge for PR #$PR_NUMBER"
          gh pr merge $PR_NUMBER --auto --squash --delete-branch || {
            echo "Auto-merge failed, attempting direct merge..."
            sleep 5
            gh pr merge $PR_NUMBER --squash --delete-branch
          }
